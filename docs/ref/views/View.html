---
title: View
layout: default
---

<h1>View</h1>

<code>
class View
    : public Todo
</code>

<h2>Identity & Hierarchy</h2>

<table>
<tr><td>void <a href="todo">addSubview</a>(<a href="class_view.html">View</a> * subview)</td><td>Adds a subview to the end of the subviews list, i.e.</td></tr>
<tr><td>void <a href="todo">insertSubview</a>(<a href="class_view.html">View</a> * subview, int index)</td><td>Inserts a subview at a particular index, z-order ascending.</td></tr>
<tr><td>void <a href="todo">removeSubview</a>(<a href="class_view.html">View</a> * subview)</td><td>Removes a subview.</td></tr>
<tr><td><a href="class_view.html">View</a> * <a href="todo">getParent</a>()</td><td>Return the parent view of this view.</td></tr>
<tr><td>void <a href="todo">removeFromParent</a>()</td><td>Removes this view from its parent view.</td></tr>
<tr><td>int <a href="todo">indexOfSubview</a>(<a href="class_view.html">View</a> * subview)</td><td>Find the index of the given subview, returns -1 if given view is not a subview.</td></tr>
<tr><td><a href="class_view.html">View</a> * <a href="todo">findViewById</a>(const string & id)</td><td>Find a view among the subviews (and all descendent views) given a string id.</td></tr>
<tr><td>void <a href="todo">removeSubviewsNotInVisibleArea</a>()</td><td>Helper to remove any subviews currently scrolled out of sight.</td></tr>
<table>

<h2>Window & Surface</h2>

<table>
<tr><td>void <a href="todo">setUsePrivateSurface</a>(bool usePrivateSurface)</td><td>Controls whether the view should render to a private surface or not.</td></tr>
<tr><td><a href="class_window.html">Window</a> * <a href="todo">getWindow</a>()</td><td>Return the Window that this View is attached to.</td></tr>
<tr><td>void <a href="todo">attachToWindow</a>(<a href="class_window.html">Window</a> * window)</td><td>Called when the view is attached to the application Window and will be drawn and able to receive input events, etc.</td></tr>
<tr><td>void <a href="todo">detachFromWindow</a>()</td><td>Called when the view is detached from the application Window.</td></tr>
<table>

<h2>Size & Position</h2>

<table>
<tr><td>float <a href="todo">getWidth</a>()</td><td>Get the width of the view.</td></tr>
<tr><td>float <a href="todo">getHeight</a>()</td><td>Get the height of the view.</td></tr>
<tr><td>RECT <a href="todo">getRect</a>()</td><td>Get the current view rect, in parent coords.</td></tr>
<tr><td>RECT <a href="todo">getOwnRect</a>()</td><td>Get the view rect in it's own coordinate system, i.e.</td></tr>
<tr><td>RECT <a href="todo">getOwnRectPadded</a>()</td><td>Same as getOwnRect() but with current padding insets applied.</td></tr>
<tr><td>POINT <a href="todo">mapPointToWindow</a>(POINT pt)</td><td>Convert a point from own-rect coordinates to window coordinates.</td></tr>
<tr><td>void <a href="todo">setPadding</a>(EDGEINSETS padding)</td><td>Set padding insets, i.e.</td></tr>
<tr><td>void <a href="todo">setMeasureSpecs</a>(MEASURESPEC widthMeasureSpec, MEASURESPEC heightMeasureSpec)</td><td>Set the size this view would like to have, given various constraints (see MEASURESPEC and measure()).</td></tr>
<tr><td>void <a href="todo">setAlignSpecs</a>(ALIGNSPEC alignspecHorz, ALIGNSPEC alignspecVert)</td><td>Set the preferred alignment within the parent view.</td></tr>
<tr><td>void <a href="todo">setNeedsLayout</a>()</td><td>Signal that the view needs to recalculate its size and position.</td></tr>
<tr><td>void <a href="todo">measure</a>(float parentWidth, float parentHeight)</td><td>Determines the view rect size, given the parent size constraint.</td></tr>
<tr><td>void <a href="todo">setRectSize</a>(const SIZE & size)</td><td>Sets the size of the view rect.</td></tr>
<tr><td>void <a href="todo">setRectOrigin</a>(const POINT & origin)</td><td>Sets the position of the view.</td></tr>
<tr><td>void <a href="todo">layout</a>()</td><td>Updates the view position, i.e.</td></tr>
<tr><td>void <a href="todo">setVisibility</a>(Visibility visibility)</td><td></td></tr>
<table>

<h2>Content & Scrolling</h2>

<table>
<tr><td>SIZE <a href="todo">getContentSize</a>()</td><td>Returns the current content size, as calculated by updateContentSize() during layout.</td></tr>
<tr><td>void <a href="todo">invalidateContentSize</a>()</td><td>Mark the view's contentSize as invalid and call setNeedsLayout()</td></tr>
<tr><td>void <a href="todo">updateContentSize</a>(float parentWidth, float parentHeight)</td><td>Called during measure() views should set the _contentSize property here.</td></tr>
<tr><td>void <a href="todo">setGravity</a>(GRAVITY gravity)</td><td>Set the gravity flags.</td></tr>
<tr><td>POINT <a href="todo">getContentOffset</a>()</td><td></td></tr>
<tr><td>void <a href="todo">setContentOffset</a>(POINT contentOffset)</td><td></td></tr>
<tr><td>void <a href="todo">setScrollInsets</a>(EDGEINSETS scrollInsets)</td><td></td></tr>
<tr><td>bool <a href="todo">canScrollHorizontally</a>()</td><td></td></tr>
<tr><td>bool <a href="todo">canScrollVertically</a>()</td><td></td></tr>
<table>

<h2>Drawing</h2>

<table>
<tr><td>void <a href="todo">setBackground</a>(RenderOp * drawableOp)</td><td></td></tr>
<tr><td>void <a href="todo">setBackground</a>(RenderOp * drawableOp, STATESET stateset)</td><td></td></tr>
<tr><td>void <a href="todo">setBackgroundColour</a>(COLOUR colour)</td><td></td></tr>
<tr><td>void <a href="todo">addRenderOp</a>(RenderOp * renderOp)</td><td></td></tr>
<tr><td>void <a href="todo">addRenderOp</a>(RenderOp * renderOp, bool atFront)</td><td></td></tr>
<tr><td>void <a href="todo">removeRenderOp</a>(RenderOp * renderOp)</td><td></td></tr>
<tr><td>void <a href="todo">setNeedsFullRedraw</a>()</td><td></td></tr>
<tr><td>void <a href="todo">invalidateRect</a>(const RECT & rect)</td><td></td></tr>
<tr><td>COLOUR <a href="todo">getTintColour</a>()</td><td></td></tr>
<tr><td>void <a href="todo">setTintColour</a>(COLOUR tintColour)</td><td>Sets tint colour.</td></tr>
<tr><td>float <a href="todo">getAlpha</a>()</td><td>Get the current alpha.</td></tr>
<tr><td>void <a href="todo">setAlpha</a>(float alpha)</td><td>Sets alpha.</td></tr>
<table>

<h2>State</h2>

<table>
<tr><td>void <a href="todo">setState</a>(STATESET stateset)</td><td>Set one or more state bits at once.</td></tr>
<tr><td>bool <a href="todo">isPressed</a>()</td><td></td></tr>
<tr><td>void <a href="todo">setPressed</a>(bool isPressed)</td><td></td></tr>
<tr><td>bool <a href="todo">isEnabled</a>()</td><td></td></tr>
<tr><td>void <a href="todo">setEnabled</a>(bool enabled)</td><td></td></tr>
<tr><td>void <a href="todo">onStateChanged</a>(STATESET changes)</td><td>Called whenever state changes.</td></tr>
<table>

<h2>Styles</h2>

<table>
<tr><td>void <a href="todo">applyStyleValues</a>(const StyleValueList & values)</td><td>Applies a set of styles to the view.</td></tr>
<tr><td>bool <a href="todo">applyStyleValue</a>(const string & name, StyleValue * value)</td><td>Applies a single style value for the given attribute name.</td></tr>
<table>

<h2>Touch</h2>

<table>
<tr><td>bool <a href="todo">isTouchable</a>()</td><td>Convenience function returning true if the view is both visible and enabled.</td></tr>
<tr><td><a href="class_view.html">View</a> * <a href="todo">hitTest</a>(POINT pt, POINT * ptRel)</td><td></td></tr>
<tr><td><a href="class_view.html">View</a> * <a href="todo">subviewContainingPoint</a>(POINT pt)</td><td></td></tr>
<tr><td>int <a href="todo">indexOfSubviewContainingPoint</a>(POINT pt)</td><td></td></tr>
<table>

<h2></h2>

<table>
<table>

<h2></h2>

<table>
<tr><td> <a href="todo">View</a>()</td><td></td></tr>
<tr><td> <a href="todo">~View</a>()</td><td></td></tr>
<tr><td><a href="class_i_keyboard_input_handler.html">IKeyboardInputHandler</a> * <a href="todo">getKeyboardInputHandler</a>()</td><td></td></tr>
<tr><td>bool <a href="todo">setFocused</a>(bool focused)</td><td></td></tr>
<tr><td>bool <a href="todo">isFocused</a>()</td><td></td></tr>
<tr><td>void <a href="todo">animateAlpha</a>(float target, float duration)</td><td></td></tr>
<tr><td>void <a href="todo">animateTranslate</a>(POINT translation, float duration)</td><td></td></tr>
<tr><td>void <a href="todo">setTranslate</a>(POINT translation)</td><td></td></tr>
<table>

<h1>Methods</h1>

<h3>addSubview</h3>
<code>void <a href="todo">addSubview</a>(<a href="class_view.html">View</a> * subview)</code><p>last in the z-order</p>

<h3>insertSubview</h3>
<code>void <a href="todo">insertSubview</a>(<a href="class_view.html">View</a> * subview, int index)</code><p></p>

<h3>removeSubview</h3>
<code>void <a href="todo">removeSubview</a>(<a href="class_view.html">View</a> * subview)</code><p></p>

<h3>getParent</h3>
<code><a href="class_view.html">View</a> * <a href="todo">getParent</a>()</code><p></p>

<h3>removeFromParent</h3>
<code>void <a href="todo">removeFromParent</a>()</code><p></p>

<h3>indexOfSubview</h3>
<code>int <a href="todo">indexOfSubview</a>(<a href="class_view.html">View</a> * subview)</code><p></p>

<h3>findViewById</h3>
<code><a href="class_view.html">View</a> * <a href="todo">findViewById</a>(const string & id)</code><p></p>

<h3>removeSubviewsNotInVisibleArea</h3>
<code>void <a href="todo">removeSubviewsNotInVisibleArea</a>()</code><p></p>

<h3>setUsePrivateSurface</h3>
<code>void <a href="todo">setUsePrivateSurface</a>(bool usePrivateSurface)</code><p>A private surface is useful when rendering is particularly expensive and likely to contribute to lag.</p>

<h3>getWindow</h3>
<code><a href="class_window.html">Window</a> * <a href="todo">getWindow</a>()</code><p>In practice this is the main application window or NULL.</p>

<h3>attachToWindow</h3>
<code>void <a href="todo">attachToWindow</a>(<a href="class_window.html">Window</a> * window)</code><p></p>

<h3>detachFromWindow</h3>
<code>void <a href="todo">detachFromWindow</a>()</code><p></p>

<h3>getWidth</h3>
<code>float <a href="todo">getWidth</a>()</code><p></p>

<h3>getHeight</h3>
<code>float <a href="todo">getHeight</a>()</code><p></p>

<h3>getRect</h3>
<code>RECT <a href="todo">getRect</a>()</code><p></p>

<h3>getOwnRect</h3>
<code>RECT <a href="todo">getOwnRect</a>()</code><p>(0,0,_rect.size.width,_rect.size.height)</p>

<h3>getOwnRectPadded</h3>
<code>RECT <a href="todo">getOwnRectPadded</a>()</code><p></p>

<h3>mapPointToWindow</h3>
<code>POINT <a href="todo">mapPointToWindow</a>(POINT pt)</code><p></p>

<h3>setPadding</h3>
<code>void <a href="todo">setPadding</a>(EDGEINSETS padding)</code><p>the space between the view rect and its content</p>

<h3>setMeasureSpecs</h3>
<code>void <a href="todo">setMeasureSpecs</a>(MEASURESPEC widthMeasureSpec, MEASURESPEC heightMeasureSpec)</code><p></p>

<h3>setAlignSpecs</h3>
<code>void <a href="todo">setAlignSpecs</a>(ALIGNSPEC alignspecHorz, ALIGNSPEC alignspecVert)</code><p>See ALIGNSPEC and layout()</p>

<h3>setNeedsLayout</h3>
<code>void <a href="todo">setNeedsLayout</a>()</code><p></p>

<h3>measure</h3>
<code>void <a href="todo">measure</a>(float parentWidth, float parentHeight)</code><p>The default implementation uses the MEASURESPECs passed to setMeasureSpecs() to calculate the view rect size.</p>

<h3>setRectSize</h3>
<code>void <a href="todo">setRectSize</a>(const SIZE & size)</code><p>CAUTION! This API exists so Views may override the size of their subviews during layout. Ideally it would not be a public API.</p>

<h3>setRectOrigin</h3>
<code>void <a href="todo">setRectOrigin</a>(const POINT & origin)</code><p>CAUTION! This API exists so Views may override the positioning of subviews during layout. Ideally this would not be a public API.</p>

<h3>layout</h3>
<code>void <a href="todo">layout</a>()</code><p>view rect origin. The default implementation uses the ALIGNSPECs passed to setAlignSpecs() to set the view position</p>

<h3>setVisibility</h3>
<code>void <a href="todo">setVisibility</a>(Visibility visibility)</code><p></p>

<h3>getContentSize</h3>
<code>SIZE <a href="todo">getContentSize</a>()</code><p>The content size is not directly settable, each view should determine it's own.</p>

<h3>invalidateContentSize</h3>
<code>void <a href="todo">invalidateContentSize</a>()</code><p></p>

<h3>updateContentSize</h3>
<code>void <a href="todo">updateContentSize</a>(float parentWidth, float parentHeight)</code><p>The defaut implementation does nothing.</p>

<h3>setGravity</h3>
<code>void <a href="todo">setGravity</a>(GRAVITY gravity)</code><p>Gravity affects how the content is aligned within the view rect when the view rect size exceeds the content size.</p>

<h3>getContentOffset</h3>
<code>POINT <a href="todo">getContentOffset</a>()</code><p></p>

<h3>setContentOffset</h3>
<code>void <a href="todo">setContentOffset</a>(POINT contentOffset)</code><p></p>

<h3>setScrollInsets</h3>
<code>void <a href="todo">setScrollInsets</a>(EDGEINSETS scrollInsets)</code><p></p>

<h3>canScrollHorizontally</h3>
<code>bool <a href="todo">canScrollHorizontally</a>()</code><p></p>

<h3>canScrollVertically</h3>
<code>bool <a href="todo">canScrollVertically</a>()</code><p></p>

<h3>setBackground</h3>
<code>void <a href="todo">setBackground</a>(RenderOp * drawableOp)</code><p></p>

<h3>setBackground</h3>
<code>void <a href="todo">setBackground</a>(RenderOp * drawableOp, STATESET stateset)</code><p></p>

<h3>setBackgroundColour</h3>
<code>void <a href="todo">setBackgroundColour</a>(COLOUR colour)</code><p></p>

<h3>addRenderOp</h3>
<code>void <a href="todo">addRenderOp</a>(RenderOp * renderOp)</code><p></p>

<h3>addRenderOp</h3>
<code>void <a href="todo">addRenderOp</a>(RenderOp * renderOp, bool atFront)</code><p></p>

<h3>removeRenderOp</h3>
<code>void <a href="todo">removeRenderOp</a>(RenderOp * renderOp)</code><p></p>

<h3>setNeedsFullRedraw</h3>
<code>void <a href="todo">setNeedsFullRedraw</a>()</code><p></p>

<h3>invalidateRect</h3>
<code>void <a href="todo">invalidateRect</a>(const RECT & rect)</code><p></p>

<h3>getTintColour</h3>
<code>COLOUR <a href="todo">getTintColour</a>()</code><p></p>

<h3>setTintColour</h3>
<code>void <a href="todo">setTintColour</a>(COLOUR tintColour)</code><p></p>

<h3>getAlpha</h3>
<code>float <a href="todo">getAlpha</a>()</code><p>Defaults to 1.0. Note that the actual alpha value used in rendering inherits (i.e. is effectively multiplied by) all ancestor alpha values.</p>

<h3>setAlpha</h3>
<code>void <a href="todo">setAlpha</a>(float alpha)</code><p></p>

<h3>setState</h3>
<code>void <a href="todo">setState</a>(STATESET stateset)</code><p>The STATESET parameter has a 'mask' member which determines the state bits that get updated.</p>

<h3>isPressed</h3>
<code>bool <a href="todo">isPressed</a>()</code><p></p>

<h3>setPressed</h3>
<code>void <a href="todo">setPressed</a>(bool isPressed)</code><p></p>

<h3>isEnabled</h3>
<code>bool <a href="todo">isEnabled</a>()</code><p></p>

<h3>setEnabled</h3>
<code>void <a href="todo">setEnabled</a>(bool enabled)</code><p></p>

<h3>onStateChanged</h3>
<code>void <a href="todo">onStateChanged</a>(STATESET changes)</code><p></p>

<h3>applyStyleValues</h3>
<code>void <a href="todo">applyStyleValues</a>(const StyleValueList & values)</code><p></p>

<h3>applyStyleValue</h3>
<code>bool <a href="todo">applyStyleValue</a>(const string & name, StyleValue * value)</code><p>Custom views should override this method to add support for custom attributes.</p>

<h3>isTouchable</h3>
<code>bool <a href="todo">isTouchable</a>()</code><p></p>

<h3>hitTest</h3>
<code><a href="class_view.html">View</a> * <a href="todo">hitTest</a>(POINT pt, POINT * ptRel)</code><p></p>

<h3>subviewContainingPoint</h3>
<code><a href="class_view.html">View</a> * <a href="todo">subviewContainingPoint</a>(POINT pt)</code><p></p>

<h3>indexOfSubviewContainingPoint</h3>
<code>int <a href="todo">indexOfSubviewContainingPoint</a>(POINT pt)</code><p></p>

<h3>View</h3>
<code> <a href="todo">View</a>()</code><p></p>

<h3>~View</h3>
<code> <a href="todo">~View</a>()</code><p></p>

<h3>getKeyboardInputHandler</h3>
<code><a href="class_i_keyboard_input_handler.html">IKeyboardInputHandler</a> * <a href="todo">getKeyboardInputHandler</a>()</code><p></p>

<h3>setFocused</h3>
<code>bool <a href="todo">setFocused</a>(bool focused)</code><p></p>

<h3>isFocused</h3>
<code>bool <a href="todo">isFocused</a>()</code><p></p>

<h3>animateAlpha</h3>
<code>void <a href="todo">animateAlpha</a>(float target, float duration)</code><p></p>

<h3>animateTranslate</h3>
<code>void <a href="todo">animateTranslate</a>(POINT translation, float duration)</code><p></p>

<h3>setTranslate</h3>
<code>void <a href="todo">setTranslate</a>(POINT translation)</code><p></p>

